-- ===================================================================
-- üéØ JCRON Benchmark Test Suite
-- ===================================================================
-- This test suite uses realistic test data generated by generate-bench-improved.ts
-- to benchmark JCRON performance with production-like workloads.
--
-- Usage:
--   psql -U postgres -d postgres -f test_jcron_benchmark.sql
--
-- Requirements:
--   1. JCRON functions must be installed (jcron.sql)
--   2. Test data loaded from benchmark JSON/SQL files
-- ===================================================================

\timing on
SET client_min_messages = WARNING;

-- ===================================================================
-- üìä CREATE TEST RESULTS TABLE
-- ===================================================================

DROP TABLE IF EXISTS jcron_benchmark_results CASCADE;

CREATE TABLE jcron_benchmark_results (
  test_id SERIAL PRIMARY KEY,
  test_name TEXT NOT NULL,
  total_tests INTEGER NOT NULL,
  valid_tests INTEGER NOT NULL,
  invalid_tests INTEGER NOT NULL,
  success_count INTEGER NOT NULL,
  error_count INTEGER NOT NULL,
  avg_execution_time_ms NUMERIC(10,3),
  min_execution_time_ms NUMERIC(10,3),
  max_execution_time_ms NUMERIC(10,3),
  patterns_per_second NUMERIC(10,2),
  complexity_breakdown JSONB,
  run_timestamp TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_benchmark_test_name ON jcron_benchmark_results(test_name);
CREATE INDEX idx_benchmark_timestamp ON jcron_benchmark_results(run_timestamp);

-- ===================================================================
-- üì• LOAD TEST DATA FROM JSONL
-- ===================================================================

-- Create temporary table to load test data
DROP TABLE IF EXISTS jcron_test_data;

CREATE TEMPORARY TABLE jcron_test_data (
  id TEXT,
  pattern TEXT,
  valid BOOLEAN,
  category TEXT,
  complexity TEXT,
  timezone TEXT,
  from_time TIMESTAMPTZ,
  expected_time TIMESTAMPTZ,
  tags TEXT[],
  expected_error TEXT
);

-- Note: Load test data using COPY or pg_read_file
-- Example: 
-- COPY jcron_test_data(id, pattern, valid, category, complexity, timezone, from_time, expected_time, tags, expected_error)
-- FROM '/path/to/benchmark_with_modifiers_1k.jsonl' WITH (FORMAT csv, DELIMITER E'\t');

-- For demonstration, we'll use inline data in comments
-- In production, load from the generated JSONL file

-- ===================================================================
-- üß™ BENCHMARK TEST 1: Valid Pattern Parsing
-- ===================================================================

DO $$
DECLARE
  v_start_time TIMESTAMPTZ;
  v_end_time TIMESTAMPTZ;
  v_duration_ms NUMERIC;
  v_success_count INTEGER := 0;
  v_error_count INTEGER := 0;
  v_test_count INTEGER;
  v_test_record RECORD;
  v_result RECORD;
  v_complexity_stats JSONB;
BEGIN
  RAISE NOTICE 'üß™ BENCHMARK TEST 1: Valid Pattern Parsing';
  RAISE NOTICE '================================================';
  
  -- Get test count
  SELECT COUNT(*) INTO v_test_count 
  FROM jcron_test_data 
  WHERE valid = TRUE;
  
  IF v_test_count = 0 THEN
    RAISE NOTICE '‚ö†Ô∏è  No test data loaded. Please load test data first.';
    RAISE NOTICE '   Run: bun run generate-bench-improved.ts --total 1000 --format sql --out test_data.sql';
    RAISE NOTICE '   Then: psql -U postgres -d postgres -f test_data.sql';
    RETURN;
  END IF;
  
  RAISE NOTICE 'Testing % valid patterns...', v_test_count;
  
  v_start_time := clock_timestamp();
  
  -- Test all valid patterns
  FOR v_test_record IN 
    SELECT * FROM jcron_test_data WHERE valid = TRUE
  LOOP
    BEGIN
      -- Test jcron_next_execution
      SELECT * INTO v_result
      FROM jcron_next_execution(
        v_test_record.pattern,
        v_test_record.from_time
      );
      
      IF v_result.is_valid THEN
        v_success_count := v_success_count + 1;
      ELSE
        v_error_count := v_error_count + 1;
        RAISE NOTICE '‚ùå Pattern failed: % - Error: %', v_test_record.pattern, v_result.error_message;
      END IF;
      
    EXCEPTION WHEN OTHERS THEN
      v_error_count := v_error_count + 1;
      RAISE NOTICE '‚ùå Exception for pattern: % - Error: %', v_test_record.pattern, SQLERRM;
    END;
  END LOOP;
  
  v_end_time := clock_timestamp();
  v_duration_ms := EXTRACT(EPOCH FROM (v_end_time - v_start_time)) * 1000;
  
  -- Calculate complexity breakdown
  SELECT jsonb_object_agg(complexity, cnt) INTO v_complexity_stats
  FROM (
    SELECT complexity, COUNT(*) as cnt
    FROM jcron_test_data
    WHERE valid = TRUE
    GROUP BY complexity
  ) stats;
  
  -- Insert results
  INSERT INTO jcron_benchmark_results (
    test_name, total_tests, valid_tests, invalid_tests,
    success_count, error_count,
    avg_execution_time_ms, patterns_per_second,
    complexity_breakdown
  ) VALUES (
    'Valid Pattern Parsing',
    v_test_count, v_test_count, 0,
    v_success_count, v_error_count,
    v_duration_ms / v_test_count,
    (v_test_count * 1000.0 / v_duration_ms),
    v_complexity_stats
  );
  
  RAISE NOTICE '';
  RAISE NOTICE '‚úÖ Results:';
  RAISE NOTICE '   Total Duration: % ms', ROUND(v_duration_ms, 2);
  RAISE NOTICE '   Success: % / %', v_success_count, v_test_count;
  RAISE NOTICE '   Errors: %', v_error_count;
  RAISE NOTICE '   Avg Time: % ms/pattern', ROUND(v_duration_ms / v_test_count, 3);
  RAISE NOTICE '   Throughput: % patterns/sec', ROUND(v_test_count * 1000.0 / v_duration_ms, 2);
  RAISE NOTICE '';
END $$;

-- ===================================================================
-- üß™ BENCHMARK TEST 2: Invalid Pattern Detection
-- ===================================================================

DO $$
DECLARE
  v_start_time TIMESTAMPTZ;
  v_end_time TIMESTAMPTZ;
  v_duration_ms NUMERIC;
  v_success_count INTEGER := 0;
  v_error_count INTEGER := 0;
  v_test_count INTEGER;
  v_test_record RECORD;
  v_result RECORD;
BEGIN
  RAISE NOTICE 'üß™ BENCHMARK TEST 2: Invalid Pattern Detection';
  RAISE NOTICE '================================================';
  
  SELECT COUNT(*) INTO v_test_count 
  FROM jcron_test_data 
  WHERE valid = FALSE;
  
  IF v_test_count = 0 THEN
    RAISE NOTICE '‚ö†Ô∏è  No invalid test patterns found.';
    RETURN;
  END IF;
  
  RAISE NOTICE 'Testing % invalid patterns...', v_test_count;
  
  v_start_time := clock_timestamp();
  
  -- Test all invalid patterns (should detect errors)
  FOR v_test_record IN 
    SELECT * FROM jcron_test_data WHERE valid = FALSE
  LOOP
    BEGIN
      SELECT * INTO v_result
      FROM jcron_next_execution(
        v_test_record.pattern,
        COALESCE(v_test_record.from_time, NOW())
      );
      
      IF NOT v_result.is_valid THEN
        v_success_count := v_success_count + 1; -- Correctly detected as invalid
      ELSE
        v_error_count := v_error_count + 1; -- Should have been invalid!
        RAISE NOTICE '‚ö†Ô∏è  Pattern should be invalid but passed: %', v_test_record.pattern;
      END IF;
      
    EXCEPTION WHEN OTHERS THEN
      v_success_count := v_success_count + 1; -- Exception is expected
    END;
  END LOOP;
  
  v_end_time := clock_timestamp();
  v_duration_ms := EXTRACT(EPOCH FROM (v_end_time - v_start_time)) * 1000;
  
  INSERT INTO jcron_benchmark_results (
    test_name, total_tests, valid_tests, invalid_tests,
    success_count, error_count,
    avg_execution_time_ms, patterns_per_second,
    complexity_breakdown
  ) VALUES (
    'Invalid Pattern Detection',
    v_test_count, 0, v_test_count,
    v_success_count, v_error_count,
    v_duration_ms / v_test_count,
    (v_test_count * 1000.0 / v_duration_ms),
    NULL
  );
  
  RAISE NOTICE '';
  RAISE NOTICE '‚úÖ Results:';
  RAISE NOTICE '   Total Duration: % ms', ROUND(v_duration_ms, 2);
  RAISE NOTICE '   Correctly Detected: % / %', v_success_count, v_test_count;
  RAISE NOTICE '   False Positives: %', v_error_count;
  RAISE NOTICE '   Avg Time: % ms/pattern', ROUND(v_duration_ms / v_test_count, 3);
  RAISE NOTICE '   Throughput: % patterns/sec', ROUND(v_test_count * 1000.0 / v_duration_ms, 2);
  RAISE NOTICE '';
END $$;

-- ===================================================================
-- üß™ BENCHMARK TEST 3: Complexity-Based Performance
-- ===================================================================

DO $$
DECLARE
  v_complexity TEXT;
  v_start_time TIMESTAMPTZ;
  v_end_time TIMESTAMPTZ;
  v_duration_ms NUMERIC;
  v_test_count INTEGER;
  v_test_record RECORD;
  v_result RECORD;
BEGIN
  RAISE NOTICE 'üß™ BENCHMARK TEST 3: Complexity-Based Performance';
  RAISE NOTICE '================================================';
  
  -- Test each complexity level
  FOR v_complexity IN 
    SELECT DISTINCT complexity 
    FROM jcron_test_data 
    WHERE valid = TRUE 
    ORDER BY complexity
  LOOP
    SELECT COUNT(*) INTO v_test_count 
    FROM jcron_test_data 
    WHERE valid = TRUE AND complexity = v_complexity;
    
    IF v_test_count = 0 THEN
      CONTINUE;
    END IF;
    
    RAISE NOTICE '';
    RAISE NOTICE 'üìä Testing % patterns (complexity: %)...', v_test_count, v_complexity;
    
    v_start_time := clock_timestamp();
    
    FOR v_test_record IN 
      SELECT * FROM jcron_test_data 
      WHERE valid = TRUE AND complexity = v_complexity
      LIMIT 100 -- Limit for faster testing
    LOOP
      SELECT * INTO v_result
      FROM jcron_next_execution(
        v_test_record.pattern,
        v_test_record.from_time
      );
    END LOOP;
    
    v_end_time := clock_timestamp();
    v_duration_ms := EXTRACT(EPOCH FROM (v_end_time - v_start_time)) * 1000;
    
    RAISE NOTICE '   Duration: % ms', ROUND(v_duration_ms, 2);
    RAISE NOTICE '   Avg Time: % ms/pattern', ROUND(v_duration_ms / LEAST(v_test_count, 100), 3);
    RAISE NOTICE '   Throughput: % patterns/sec', ROUND(LEAST(v_test_count, 100) * 1000.0 / v_duration_ms, 2);
  END LOOP;
  
  RAISE NOTICE '';
END $$;

-- ===================================================================
-- üß™ BENCHMARK TEST 4: Feature-Specific Tests
-- ===================================================================

DO $$
DECLARE
  v_feature TEXT;
  v_test_count INTEGER;
  v_start_time TIMESTAMPTZ;
  v_end_time TIMESTAMPTZ;
  v_duration_ms NUMERIC;
  v_test_record RECORD;
  v_result RECORD;
BEGIN
  RAISE NOTICE 'üß™ BENCHMARK TEST 4: Feature-Specific Performance';
  RAISE NOTICE '================================================';
  
  -- Test WOY patterns
  SELECT COUNT(*) INTO v_test_count 
  FROM jcron_test_data 
  WHERE valid = TRUE AND pattern LIKE '%WOY%';
  
  IF v_test_count > 0 THEN
    RAISE NOTICE '';
    RAISE NOTICE 'üìä Testing WOY (Week of Year) patterns: %...', v_test_count;
    
    v_start_time := clock_timestamp();
    
    FOR v_test_record IN 
      SELECT * FROM jcron_test_data 
      WHERE valid = TRUE AND pattern LIKE '%WOY%'
      LIMIT 50
    LOOP
      SELECT * INTO v_result
      FROM jcron_next_execution(v_test_record.pattern, v_test_record.from_time);
    END LOOP;
    
    v_end_time := clock_timestamp();
    v_duration_ms := EXTRACT(EPOCH FROM (v_end_time - v_start_time)) * 1000;
    
    RAISE NOTICE '   Duration: % ms', ROUND(v_duration_ms, 2);
    RAISE NOTICE '   Avg Time: % ms/pattern', ROUND(v_duration_ms / LEAST(v_test_count, 50), 3);
    RAISE NOTICE '   Throughput: % patterns/sec', ROUND(LEAST(v_test_count, 50) * 1000.0 / v_duration_ms, 2);
  END IF;
  
  -- Test EOD/SOD patterns
  SELECT COUNT(*) INTO v_test_count 
  FROM jcron_test_data 
  WHERE valid = TRUE AND (pattern LIKE '%E1%' OR pattern LIKE '%S1%');
  
  IF v_test_count > 0 THEN
    RAISE NOTICE '';
    RAISE NOTICE 'üìä Testing EOD/SOD patterns: %...', v_test_count;
    
    v_start_time := clock_timestamp();
    
    FOR v_test_record IN 
      SELECT * FROM jcron_test_data 
      WHERE valid = TRUE AND (pattern LIKE '%E1%' OR pattern LIKE '%S1%')
      LIMIT 50
    LOOP
      SELECT * INTO v_result
      FROM jcron_next_execution(v_test_record.pattern, v_test_record.from_time);
    END LOOP;
    
    v_end_time := clock_timestamp();
    v_duration_ms := EXTRACT(EPOCH FROM (v_end_time - v_start_time)) * 1000;
    
    RAISE NOTICE '   Duration: % ms', ROUND(v_duration_ms, 2);
    RAISE NOTICE '   Avg Time: % ms/pattern', ROUND(v_duration_ms / LEAST(v_test_count, 50), 3);
    RAISE NOTICE '   Throughput: % patterns/sec', ROUND(LEAST(v_test_count, 50) * 1000.0 / v_duration_ms, 2);
  END IF;
  
  -- Test Timezone patterns
  SELECT COUNT(*) INTO v_test_count 
  FROM jcron_test_data 
  WHERE valid = TRUE AND pattern LIKE 'TZ:%';
  
  IF v_test_count > 0 THEN
    RAISE NOTICE '';
    RAISE NOTICE 'üìä Testing Timezone patterns: %...', v_test_count;
    
    v_start_time := clock_timestamp();
    
    FOR v_test_record IN 
      SELECT * FROM jcron_test_data 
      WHERE valid = TRUE AND pattern LIKE 'TZ:%'
      LIMIT 50
    LOOP
      SELECT * INTO v_result
      FROM jcron_next_execution(v_test_record.pattern, v_test_record.from_time);
    END LOOP;
    
    v_end_time := clock_timestamp();
    v_duration_ms := EXTRACT(EPOCH FROM (v_end_time - v_start_time)) * 1000;
    
    RAISE NOTICE '   Duration: % ms', ROUND(v_duration_ms, 2);
    RAISE NOTICE '   Avg Time: % ms/pattern', ROUND(v_duration_ms / LEAST(v_test_count, 50), 3);
    RAISE NOTICE '   Throughput: % patterns/sec', ROUND(LEAST(v_test_count, 50) * 1000.0 / v_duration_ms, 2);
  END IF;
  
  RAISE NOTICE '';
END $$;

-- ===================================================================
-- üìä DISPLAY BENCHMARK SUMMARY
-- ===================================================================

\echo ''
\echo 'üìä BENCHMARK SUMMARY'
\echo '================================================'

SELECT 
  test_name,
  total_tests,
  success_count,
  error_count,
  ROUND(avg_execution_time_ms, 3) || ' ms' as avg_time,
  ROUND(patterns_per_second, 2) || ' patterns/sec' as throughput,
  to_char(run_timestamp, 'YYYY-MM-DD HH24:MI:SS') as run_time
FROM jcron_benchmark_results
ORDER BY test_id;

\echo ''
\echo 'üìà COMPLEXITY BREAKDOWN'
\echo '================================================'

SELECT 
  test_name,
  complexity_breakdown
FROM jcron_benchmark_results
WHERE complexity_breakdown IS NOT NULL;

\echo ''
\echo '‚úÖ Benchmark Complete!'
\echo ''
